"""add visualization model

Revision ID: ca84ec3273b7
Revises: b05d701bf229
Create Date: 2025-09-12 16:49:45.362084

"""
from typing import Sequence, Union
import json
import uuid

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'ca84ec3273b7'
down_revision: Union[str, None] = 'b05d701bf229'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('visualizations',
    sa.Column('title', sa.String(), nullable=False),
    sa.Column('status', sa.String(), nullable=False),
    sa.Column('report_id', sa.String(length=36), nullable=False),
    sa.Column('query_id', sa.String(length=36), nullable=False),
    sa.Column('view', sa.JSON(), nullable=True),
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.Column('deleted_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['query_id'], ['queries.id'], ),
    sa.ForeignKeyConstraint(['report_id'], ['reports.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('visualizations', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_visualizations_id'), ['id'], unique=True)
        batch_op.create_index(batch_op.f('ix_visualizations_query_id'), ['query_id'], unique=False)
        batch_op.create_index(batch_op.f('ix_visualizations_report_id'), ['report_id'], unique=False)
    # Retro creation: create one Visualization per Query using its default Step's data_model
    conn = op.get_bind()

    # Fetch queries that have a default_step_id
    queries = conn.execute(sa.text(
        """
        SELECT q.id AS query_id,
               q.title AS query_title,
               q.report_id AS query_report_id,
               q.widget_id AS widget_id,
               q.default_step_id AS default_step_id
        FROM queries q
        WHERE q.default_step_id IS NOT NULL
        """
    )).fetchall()

    for q in queries:
        try:
            query_id = q.query_id
            step_id = q.default_step_id
            title = q.query_title or ""

            # Resolve report_id: prefer query.report_id, fallback via widget.report_id
            report_id = q.query_report_id
            if report_id is None and q.widget_id is not None:
                row = conn.execute(sa.text("SELECT report_id FROM widgets WHERE id = :wid"), {"wid": q.widget_id}).first()
                report_id = row[0] if row else None
            if report_id is None:
                # Cannot place visualization without a report
                continue

            # Load data_model from the default step
            dm_row = conn.execute(sa.text("SELECT data_model FROM steps WHERE id = :sid"), {"sid": step_id}).first()
            if not dm_row:
                continue
            dm_val = dm_row[0]
            try:
                data_model = json.loads(dm_val) if isinstance(dm_val, str) else dm_val
            except Exception:
                data_model = None
            if not isinstance(data_model, dict):
                data_model = {}

            # Build minimal view: type (as-is) + encoding derived from series only
            v_type = data_model.get("type")
            encoding = None
            try:
                series = data_model.get("series") or []
                if isinstance(series, list) and series and isinstance(series[0], dict):
                    first = series[0]
                    cat = first.get("key")
                    val = first.get("value")
                    if cat and val:
                        # Single series encoding; if multiple series, keep names/values set
                        if len(series) == 1:
                            encoding = {"category": str(cat), "value": str(val)}
                            if first.get("name"):
                                encoding["name"] = str(first.get("name"))
                        else:
                            encoding = {
                                "category": str(cat),
                                "series": [
                                    {k: str(v) for k, v in {"name": s.get("name"), "value": s.get("value")}.items() if v is not None}
                                    for s in series if isinstance(s, dict)
                                ]
                            }
            except Exception:
                encoding = None

            view_obj = {"specVersion": 1}
            if v_type is not None:
                view_obj["type"] = v_type
            if encoding is not None:
                view_obj["encoding"] = encoding

            vis_id = str(uuid.uuid4())
            conn.execute(sa.text(
                """
                INSERT INTO visualizations (id, title, status, report_id, query_id, view, created_at, updated_at)
                VALUES (:id, :title, :status, :report_id, :query_id, :view, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
                """
            ), {
                "id": vis_id,
                "title": title,
                "status": "draft",
                "report_id": str(report_id),
                "query_id": str(query_id),
                "view": json.dumps(view_obj),
            })
        except Exception:
            # Best-effort backfill; skip on errors
            continue
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###

    with op.batch_alter_table('visualizations', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_visualizations_report_id'))
        batch_op.drop_index(batch_op.f('ix_visualizations_query_id'))
        batch_op.drop_index(batch_op.f('ix_visualizations_id'))

    op.drop_table('visualizations')
    # ### end Alembic commands ###
